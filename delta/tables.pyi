#
# Copyright 2021 zero323
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from delta._typing import (
    ColumnMapping as ColumnMapping,
    ExpressionOrColumn as ExpressionOrColumn,
    OptionalColumnMapping as OptionalColumnMapping,
    OptionalExpressionOrColumn as OptionalExpressionOrColumn,
)
from py4j.java_collections import JavaMap as JavaMap  # type: ignore[import]
from py4j.java_gateway import JVMView as JVMView, JavaObject as JavaObject  # type: ignore[import]
from pyspark.sql import DataFrame, SparkSession
from pyspark.sql.types import DataType, StructField, StructType
from typing import List, Optional, Tuple, Union, overload

class DeltaTable:
    def __init__(self, spark: SparkSession, jdt: JavaObject) -> None: ...
    def toDF(self) -> DataFrame: ...
    def alias(self, aliasName: str) -> DeltaTable: ...
    def generate(self, mode: str) -> None: ...
    def delete(self, condition: OptionalExpressionOrColumn = ...) -> None: ...
    @overload
    def update(self, condition: ExpressionOrColumn, set: ColumnMapping) -> None: ...
    @overload
    def update(self, set: ColumnMapping) -> None: ...
    def merge(
        self, source: DataFrame, condition: ExpressionOrColumn
    ) -> DeltaMergeBuilder: ...
    def vacuum(self, retentionHours: Optional[float] = ...) -> DataFrame: ...
    def history(self, limit: Optional[int] = ...) -> DataFrame: ...
    @classmethod
    def convertToDelta(
        cls,
        sparkSession: SparkSession,
        identifier: str,
        partitionSchema: Optional[Union[str, StructType]] = ...,
    ) -> DeltaTable: ...
    @classmethod
    def forPath(cls, sparkSession: SparkSession, path: str) -> DeltaTable: ...
    @classmethod
    def forName(
        cls, sparkSession: SparkSession, tableOrViewName: str
    ) -> DeltaTable: ...
    @classmethod
    def create(
        cls, sparkSession: Optional[SparkSession] = ...
    ) -> DeltaTableBuilder: ...
    @classmethod
    def createIfNotExists(
        cls, sparkSession: Optional[SparkSession] = ...
    ) -> DeltaTableBuilder: ...
    @classmethod
    def replace(
        cls, sparkSession: Optional[SparkSession] = ...
    ) -> DeltaTableBuilder: ...
    @classmethod
    def createOrReplace(
        cls, sparkSession: Optional[SparkSession] = ...
    ) -> DeltaTableBuilder: ...
    @classmethod
    def isDeltaTable(cls, sparkSession: SparkSession, identifier: str) -> bool: ...
    def upgradeTableProtocol(self, readerVersion: int, writerVersion: int) -> None: ...

class DeltaMergeBuilder:
    def __init__(self, spark: SparkSession, jbuilder: JavaObject) -> None: ...
    @overload
    def whenMatchedUpdate(
        self, condition: OptionalExpressionOrColumn, set: ColumnMapping
    ) -> DeltaMergeBuilder: ...
    @overload
    def whenMatchedUpdate(self, set: ColumnMapping) -> DeltaMergeBuilder: ...
    def whenMatchedUpdateAll(
        self, condition: OptionalExpressionOrColumn = ...
    ) -> DeltaMergeBuilder: ...
    def whenMatchedDelete(
        self, condition: OptionalExpressionOrColumn = ...
    ) -> DeltaMergeBuilder: ...
    @overload
    def whenNotMatchedInsert(
        self, condition: ExpressionOrColumn, values: ColumnMapping
    ) -> DeltaMergeBuilder: ...
    @overload
    def whenNotMatchedInsert(
        self, *, values: ColumnMapping = ...
    ) -> DeltaMergeBuilder: ...
    def whenNotMatchedInsertAll(
        self, condition: OptionalExpressionOrColumn = ...
    ) -> DeltaMergeBuilder: ...
    def execute(self) -> None: ...

class DeltaTableBuilder:
    def __init__(self, spark: SparkSession, jbuilder: JavaObject) -> None: ...
    def tableName(self, identifier: str) -> DeltaTableBuilder: ...
    def location(self, location: str) -> DeltaTableBuilder: ...
    def comment(self, comment: str) -> DeltaTableBuilder: ...
    def addColumn(
        self,
        colName: str,
        dataType: Union[str, DataType],
        nullable: bool = ...,
        generatedAlwaysAs: Optional[str] = ...,
        comment: Optional[str] = ...,
    ) -> DeltaTableBuilder: ...
    def addColumns(
        self, cols: Union[StructType, List[StructField]]
    ) -> DeltaTableBuilder: ...
    def partitionedBy(
        self, *cols: Union[str, List[str], Tuple[str, ...]]
    ) -> DeltaTableBuilder: ...
    def property(self, key: str, value: str) -> DeltaTableBuilder: ...
    def execute(self) -> DeltaTable: ...
